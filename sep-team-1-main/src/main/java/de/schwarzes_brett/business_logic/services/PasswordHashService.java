package de.schwarzes_brett.business_logic.services;

import de.schwarzes_brett.business_logic.exception.HashingUnavailableException;
import de.schwarzes_brett.dto.PasswordDTO;
import jakarta.enterprise.context.Dependent;
import jakarta.inject.Inject;
import jakarta.inject.Named;

import java.io.Serial;
import java.io.Serializable;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Random;
import java.util.logging.Logger;

/**
 * Can be used to hash passwords. Hashed passwords are generated as hex string values with the
 * use of a salt. The class also offers means to validate passwords.
 *
 * @author Daniel Lipp
 */
@Named
@Dependent
public class PasswordHashService implements Serializable {

    @Serial
    private static final long serialVersionUID = 1L;
    /**
     * Length used for generating new salts.
     */
    private static final int SALT_LENGTH = 16;
    /**
     * Algorithm used to hash passwords.
     */
    private static final String HASHING_ALGORITHM = "SHA-512";
    private static final String SALT_ALGO = "SHA1PRNG";
    /**
     * Random number generator for generating a salt to a password.
     */
    private final Random saltGenerator;
    /**
     * The {@code Logger} instance to be used in this class.
     */
    @Inject
    private transient Logger logger;

    /**
     * Constructs a new PasswordHashService.
     */
    public PasswordHashService() {
        Random saltGenerator1;
        try {
            saltGenerator1 = SecureRandom.getInstance(SALT_ALGO);
        } catch (NoSuchAlgorithmException e) {
            logger.severe("Salt generating algorithm could not be found: " + e.getMessage());
            saltGenerator1 = new SecureRandom();
        }
        saltGenerator = saltGenerator1;
    }

    /**
     * Hashes a password with the given salt. The used algorithm is SHA-256
     *
     * @param passwordToHash password to be hashed
     * @param salt           salt used for hashing
     * @return hashed password.
     */
    public String hashPassword(String passwordToHash,
                               String salt) {
        String generatedPassword;
        try {
            MessageDigest md = MessageDigest.getInstance(HASHING_ALGORITHM);
            md.update(salt.getBytes(StandardCharsets.UTF_8));
            byte[] bytes = md.digest(passwordToHash.getBytes(StandardCharsets.UTF_8));
            generatedPassword = bytesToHex(bytes);
        } catch (NoSuchAlgorithmException e) {
            String message = "Hashing algorithm \"" + HASHING_ALGORITHM + "\" could not be found: " + e.getMessage();
            logger.severe(message);
            throw new HashingUnavailableException(message);
        }
        return generatedPassword;
    }

    /**
     * Creates a PasswordDTO from the given password to hash and the salt.
     *
     * @param passwordToHash password to be hashed
     * @param salt           salt for hashing the password
     * @return new PasswordDTO containing the salt and hashed password.
     */
    public PasswordDTO createPasswordDTO(String passwordToHash,
                                         String salt) {
        PasswordDTO passwordDTO = new PasswordDTO();
        passwordDTO.setPasswordHash(hashPassword(passwordToHash, salt));
        passwordDTO.setPwdSalt(salt);
        return passwordDTO;
    }

    /**
     * Creates a PasswordDTO from the given password to hash with a new generated salt.
     *
     * @param passwordToHash password to be hashed
     * @return new PasswordDTO containing the salt and hashed password.
     */
    public PasswordDTO createPasswordDTO(String passwordToHash) {
        return createPasswordDTO(passwordToHash, generateSalt());
    }

    /**
     * Generates a salt for a password hash.
     *
     * @return new random salt.
     */
    public String generateSalt() {
        byte[] salt = new byte[SALT_LENGTH];
        saltGenerator.nextBytes(salt);
        return bytesToHex(salt);
    }

    /**
     * Generates a string representation of a byte array. The string is generated by hex encoding.
     *
     * @param bytes bytes to be converted.
     * @return hex string representation of the input
     */
    private String bytesToHex(final byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }
}
